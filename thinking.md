# 工厂方法与抽象工厂的异同点
* 相同点：

都对客户端隐藏了创建细节。

* 不同点：

工厂方法模式中，客户端直接将工厂视为产品使用，但工厂会有一定程度的产品包装。

抽象工厂模式中，客户端通过工厂生成一系列相关产品，然后自行组织产品的使用。

# 原型模式和抽象工厂模式/工厂方法模式
* 原型模式可以通过工厂类对原型进行预生成，然后按照原型类型，通过工厂类进行原型的复制，在客户端看来，是通过传递一个原型类型就可以从工厂中得到相应类型的对象，而不需要了解其创建细节。

* 原型模式保证的职责是通过复制得到一个对象。

* 抽象工厂模式保证的职责是可以通过工厂进行一系列产品（就原型而言，不可能只有一个）的生成。

* 工厂方法模式保证的职责是通过工厂直接使用产品，虽然有时候是经过一定的包装的。

# 单例模式的线程安全问题
* 单例模式希望保证全局只有一个对象可以进行访问，但在多线程场景下，可能全局访问点还未初始化时就有线程需要访问，就是说第一次创建静态全局访问点（指针）还未完成时就有线程访问，此时由于指针还未初始化，线程又创建了一个新的单例对象，继而破坏了单例模式所希望实现的单一全局访问点。

* 单例的优点在于不需要为每个需要访问的线程创建对象，使用一个全局访问点供线程共享访问，实现了资源的复用，也能有助于线程之间的通信

* 客户端并不知道单例对象只有一个，同样向客户端隐藏了创建细节

# 建造者模式/生成者模式与抽象工厂膜式
* 建造者是核心，了解如何创建产品的一部分，相比于抽象工厂是创建多个相关的产品，其物理意义不同

* 可以通过指导者约束创建过程进行进一步封装，也可以通过与建造者交互自定义创建的步骤，但这样暴露了一定细节。

* 产品某部分的创建细节仍然是对客户端隐藏的，客户端不知道这部分怎么建造的
