# 工厂方法与抽象工厂的异同点
* 相同点：

都对客户端隐藏了创建细节。

* 不同点：

工厂方法模式中，客户端直接将工厂视为产品使用，但工厂会有一定程度的产品包装。

抽象工厂模式中，客户端通过工厂生成一系列相关产品，然后自行组织产品的使用。

# 原型模式和抽象工厂模式/工厂方法模式
* 原型模式可以通过工厂类对原型进行预生成，然后按照原型类型，通过工厂类进行原型的复制，在客户端看来，是通过传递一个原型类型就可以从工厂中得到相应类型的对象，而不需要了解其创建细节。

* 原型模式保证的职责是通过复制得到一个对象。

* 抽象工厂模式保证的职责是可以通过工厂进行一系列产品（就原型而言，不可能只有一个）的生成。

* 工厂方法模式保证的职责是通过工厂直接使用产品，虽然有时候是经过一定的包装的。

# 单例模式的线程安全问题
* 单例模式希望保证全局只有一个对象可以进行访问，但在多线程场景下，可能全局访问点还未初始化时就有线程需要访问，就是说第一次创建静态全局访问点（指针）还未完成时就有线程访问，此时由于指针还未初始化，线程又创建了一个新的单例对象，继而破坏了单例模式所希望实现的单一全局访问点。

* 单例的优点在于不需要为每个需要访问的线程创建对象，使用一个全局访问点供线程共享访问，实现了资源的复用，也能有助于线程之间的通信

* 客户端并不知道单例对象只有一个，同样向客户端隐藏了创建细节

# 建造者模式/生成者模式与抽象工厂膜式
* 建造者是核心，了解如何创建产品的一部分，相比于抽象工厂是创建多个相关的产品，其物理意义不同

* 可以通过指导者约束创建过程进行进一步封装，也可以通过与建造者交互自定义创建的步骤，但这样暴露了一定细节。

* 产品某部分的创建细节仍然是对客户端隐藏的，客户端不知道这部分怎么建造的

# 模板方法模式和策略模式
* 模板方法基于继承机制，通过子类的扩展来改变部分算法，在类层次上运作，是静态的，编译期就确定了行为。

* 策略模式基于组合机制，通过为相应的行为提供不同的策略来改变对象的部分行为，在对象层次上运作，是动态的，允许在运行时切换行为。

# 观察者模式
* 观察者模式实现了一对多的依赖关系，当观察目标（稳定）发生状态变化时，能够实现对观察者的逐一通知。可扩展性体现与同一观察目标的观察者是可以增加或移除的。

* 观察者模式实现了观察者和观察目标的松耦合，可以独立地改变观察目标和观察者。

# 装饰器模式
* 使用组合而非继承的方式实现了动态扩展对象功能。避免了继承带来的灵活性差和多子类衍生问题

* 装饰器类需要继承自组件类，说明装饰器也有组件的相关接口。装饰器也组合了组件类指针，用来实现运行时的多态。

# 桥模式
* 分离了抽象部分和实现部分，可以更泛化为两个强变化的方向。基于集成来对抽象进行扩展，基于组合（实现类指针）满足多态性，达到实现的扩展。

* 抽象一般指与软件相关的部分，实现一般指与硬件相关的部分，区分于面向对象中的抽象与实现。

# 享元模式
* 享元模式主要是用于解决系统中存在太多细粒度对象导致的内存问题，主要思路是通过共享对象的内部状态（那些不可被修改，每个细粒度对象都具备，可以共享的一些成员变量）来实现对象内存的减少。

* 共享的机制主要是根据内部状态的键找到对应的享元（由内部状态组成的对象），而一些不能共享的成员变量由外部使用享元对象的类或客户端保存，可以通过参数传递的方式注入享元对象。

# 外观模式
* 外观模式主要用于隔离子系统内部的变化和客户端的变化，使客户端在使用子系统时不需要关注其接口变化，也不需要关注子系统具体依赖和实现。

* 当子系统内部依赖关系复杂，接口不统一，调用不方便时可以使用外观模式简化接口的使用，将接口调用的依赖关系约束留给外观类来实现，减少客户端的使用成本。

# 代理模式
* 当实际主体对象的创建 、访问权限等直接访问方式受到限制或有较大的复杂性，客户端可以通过代理对象进行间接访问。

* 代理对象实现了与实际主体对象一致或相近的接口，在客户端看来与直接访问实际主体对象没有差异，具有透明性的访问就是代理模式的核心。当然，一定程度的牺牲透明性来换取间接访问的可实现性是可以接受的。