# 工厂方法与抽象工厂的异同点
* 相同点：

都对客户端隐藏了创建细节。

* 不同点：

工厂方法模式中，客户端直接将工厂视为产品使用，但工厂会有一定程度的产品包装。

抽象工厂模式中，客户端通过工厂生成一系列相关产品，然后自行组织产品的使用。

# 原型模式和抽象工厂模式/工厂方法模式
* 原型模式可以通过工厂类对原型进行预生成，然后按照原型类型，通过工厂类进行原型的复制，在客户端看来，是通过传递一个原型类型就可以从工厂中得到相应类型的对象，而不需要了解其创建细节。

* 原型模式保证的职责是通过复制得到一个对象。

* 抽象工厂模式保证的职责是可以通过工厂进行一系列产品（就原型而言，不可能只有一个）的生成。

* 工厂方法模式保证的职责是通过工厂直接使用产品，虽然有时候是经过一定的包装的。

# 单例模式的线程安全问题
* 单例模式希望保证全局只有一个对象可以进行访问，但在多线程场景下，可能全局访问点还未初始化时就有线程需要访问，就是说第一次创建静态全局访问点（指针）还未完成时就有线程访问，此时由于指针还未初始化，线程又创建了一个新的单例对象，继而破坏了单例模式所希望实现的单一全局访问点。

* 单例的优点在于不需要为每个需要访问的线程创建对象，使用一个全局访问点供线程共享访问，实现了资源的复用，也能有助于线程之间的通信

* 客户端并不知道单例对象只有一个，同样向客户端隐藏了创建细节

# 建造者模式/生成者模式与抽象工厂膜式
* 建造者是核心，了解如何创建产品的一部分，相比于抽象工厂是创建多个相关的产品，其物理意义不同

* 可以通过指导者约束创建过程进行进一步封装，也可以通过与建造者交互自定义创建的步骤，但这样暴露了一定细节。

* 产品某部分的创建细节仍然是对客户端隐藏的，客户端不知道这部分怎么建造的

# 模板方法模式和策略模式
* 模板方法基于继承机制，通过子类的扩展来改变部分算法，在类层次上运作，是静态的，编译期就确定了行为。

* 策略模式基于组合机制，通过为相应的行为提供不同的策略来改变对象的部分行为，在对象层次上运作，是动态的，允许在运行时切换行为。

# 观察者模式
* 观察者模式实现了一对多的依赖关系，当观察目标（稳定）发生状态变化时，能够实现对观察者的逐一通知。可扩展性体现与同一观察目标的观察者是可以增加或移除的。

* 观察者模式实现了观察者和观察目标的松耦合，可以独立地改变观察目标和观察者。

# 装饰器模式
* 使用组合而非继承的方式实现了动态扩展对象功能。避免了继承带来的灵活性差和多子类衍生问题

* 装饰器类需要继承自组件类，说明装饰器也有组件的相关接口。装饰器也组合了组件类指针，用来实现运行时的多态。

# 桥模式
* 分离了抽象部分和实现部分，可以更泛化为两个强变化的方向。基于集成来对抽象进行扩展，基于组合（实现类指针）满足多态性，达到实现的扩展。

* 抽象一般指与软件相关的部分，实现一般指与硬件相关的部分，区分于面向对象中的抽象与实现。

# 享元模式
* 享元模式主要是用于解决系统中存在太多细粒度对象导致的内存问题，主要思路是通过共享对象的内部状态（那些不可被修改，每个细粒度对象都具备，可以共享的一些成员变量）来实现对象内存的减少。

* 共享的机制主要是根据内部状态的键找到对应的享元（由内部状态组成的对象），而一些不能共享的成员变量由外部使用享元对象的类或客户端保存，可以通过参数传递的方式注入享元对象。

# 外观模式
* 外观模式主要用于隔离子系统内部的变化和客户端的变化，使客户端在使用子系统时不需要关注其接口变化，也不需要关注子系统具体依赖和实现。

* 当子系统内部依赖关系复杂，接口不统一，调用不方便时可以使用外观模式简化接口的使用，将接口调用的依赖关系约束留给外观类来实现，减少客户端的使用成本。

# 代理模式
* 当实际主体对象的创建 、访问权限等直接访问方式受到限制或有较大的复杂性，客户端可以通过代理对象进行间接访问。

* 代理对象实现了与实际主体对象一致或相近的接口，在客户端看来与直接访问实际主体对象没有差异，具有透明性的访问就是代理模式的核心。当然，一定程度的牺牲透明性来换取间接访问的可实现性是可以接受的。

# 适配器模式
* 当目标接口和已有实现的接口不相符，希望复用已有的实现的时候可以使用适配器模式。

* 适配器继承了目标接口的接口定义（public），同时组合了已有实现的指针（也可以看为是一种接口），实现两种接口的转换。这种实现称为对象适配器。

* c++还可以通过实现继承（protected或private）的多继承方式进行已实现接口的复用，这种实现称为类适配器。

# 中介者模式
* 中介者模式解决的是多个相互关联的对象之间依赖关系的解耦。他们之间的关联引用关系可能是相当复杂的。引入一个中介者类与每个对象进行双向关联，从而降低了复杂关联的耦合。

* 相比于外观模式，中介者模式是引入中介者类来降低系统内部多个相互关联对象之间的耦合。而外观模式是引入外观类来降低系统内外之间的复杂耦合。

# 状态模式
* 状态模式解决的是对象的操作随内部状态变化或转换而发生变化的场景。操作就是对象的方法，会随着内部状态的变化而表现为不同的形式。

* 状态模式采用组合的方式来将相应的行为委托给具体的状态对象，让状态对象自己控制相应的行为以及状态的转换。

* 状态模式与策略模式很相似，都是使用组合的方式将不同的任务委托给不同的相应状态对象或策略对象。不同点在于状态之间是存在依赖关系，可以相互转换的，而策略对象一般是独立的。

# 备忘录模式
* 备忘录模式解决的是在不破坏封装性的前提下，捕获一个对象的内部状态并加以保存以及后续的恢复。

* 通过对象自身提供一种快照功能，在不破坏封装性的前提下可以访问对象的所有成员和成员函数，将快照保存为一个相应的备忘录对象。

* 目前的技术而言，使用对象的序列化表示是对对象状态保存的一种高效手段。

* 在对象外部，应该有一个统一管理备忘录对象的类，实现备忘录的添加，撤销和恢复等功能。


# =====数据结构模式======

# 组合模式
* 组合模式解决的是单一对象和对象容器之间不一致性。客户代码需要与保存对象的数据结构交互，就暴露了对象容器的细节。在不破坏封装性的基础上对复杂的对象容器进行访问。

* 组合模式将对象构建成树形结构，使对象和对象容器具有同样的地位。处理的接口也一致。

* 策略模式，状态模式等都是使用组合将具体任务委托给另一个对象进行处理，而组合模式在于委托的目标与委托的发起者是同一个类。

# 迭代器模式
* 迭代器模式解决的是应对不同对象集合的内部结构时，希望能在不暴露内部结构的前提下对集合的元素进行遍历。也可以为不同类型的元素访问提供统一的接口，为泛型算法提供可能性。

* 迭代器的现代实现是基于泛型编程，而不再采用面向对象的方式，主要的区别在于泛型编程是编译时多态，没有虚函数的运行成本。

# 职责链模式
* 职责链模式解决的是当一个请求可能有多个接受对象，而运行时只有一个接受对象对其进行处理的场景。用于请求的发送者与接受者之间的解耦。

* 请求沿着职责链传递，直到有一个对象处理它，当没有下一个接收对象时，职责链可能需要一个默认的请求处理。

# =====行为变化模式=====

# 命令模式
* 命令模式解决的是“请求发起者”和“请求实现者”之间的解耦。核心是将请求/命令/操作/行为抽象为对象。

* 命令模式与策略模式很类似，都是行为上的变化，但目的大不相同。命令模式强调命令本身作为对象可以进一步完成的工作，如延迟、队列、保存等，而策略模式强调的是在一个上下文类里完成某件事的不同算法。
